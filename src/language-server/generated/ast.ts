/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type ExportedFunctionDeclaration = FunctionDeclaration;

export const ExportedFunctionDeclaration = 'ExportedFunctionDeclaration';

export function isExportedFunctionDeclaration(item: unknown): item is ExportedFunctionDeclaration {
    return reflection.isInstance(item, ExportedFunctionDeclaration);
}

export type ExportedVariableDeclaration = VariableDeclaration;

export const ExportedVariableDeclaration = 'ExportedVariableDeclaration';

export function isExportedVariableDeclaration(item: unknown): item is ExportedVariableDeclaration {
    return reflection.isInstance(item, ExportedVariableDeclaration);
}

export type Expression = BinaryExpression | CallExpression | GroupLiteral | Identifier | InvalidParenthesis | NumberLiteral;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type FunctionDeclaration = GeneratorFunctionDeclaration | OriginalFunctionDeclaration;

export const FunctionDeclaration = 'FunctionDeclaration';

export function isFunctionDeclaration(item: unknown): item is FunctionDeclaration {
    return reflection.isInstance(item, FunctionDeclaration);
}

export type FunctionExpression = ArrowFunctionExpression | GeneratorFunctionExpression | OriginalFunctionExpression;

export const FunctionExpression = 'FunctionExpression';

export function isFunctionExpression(item: unknown): item is FunctionExpression {
    return reflection.isInstance(item, FunctionExpression);
}

export type NamedElement = FunctionDeclaration | ImportSpecifier | Parameter | VariableDeclaration;

export const NamedElement = 'NamedElement';

export function isNamedElement(item: unknown): item is NamedElement {
    return reflection.isInstance(item, NamedElement);
}

export type NumberLiteral = FloatLiteral | IntegerLiteral;

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export type Statement = Block | EmptyStatement | Expression | FunctionDeclaration | ReturnStatement | VariableDeclaration;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type TopLevelStatement = ExportSpecifier | ExportedFunctionDeclaration | ExportedVariableDeclaration | ImportDeclaration | Statement | TypeDeclaration;

export const TopLevelStatement = 'TopLevelStatement';

export function isTopLevelStatement(item: unknown): item is TopLevelStatement {
    return reflection.isInstance(item, TopLevelStatement);
}

export interface ArrowFunctionExpression extends AstNode {
    readonly $type: 'ArrowFunctionExpression';
    body: ArrowReturnExpression | Block
    parameters: Array<Parameter>
    returnType?: TypeExpression
}

export const ArrowFunctionExpression = 'ArrowFunctionExpression';

export function isArrowFunctionExpression(item: unknown): item is ArrowFunctionExpression {
    return reflection.isInstance(item, ArrowFunctionExpression);
}

export interface ArrowReturnExpression extends AstNode {
    readonly $container: ArrowFunctionExpression;
    readonly $type: 'ArrowReturnExpression';
    expression: Expression
}

export const ArrowReturnExpression = 'ArrowReturnExpression';

export function isArrowReturnExpression(item: unknown): item is ArrowReturnExpression {
    return reflection.isInstance(item, ArrowReturnExpression);
}

export interface BinaryExpression extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'BinaryExpression';
    leftOperand: Expression
    operator: '*' | '+' | '-' | '/' | '='
    rightOperand: Expression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface Block extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'Block';
    statements: Array<Statement>
}

export const Block = 'Block';

export function isBlock(item: unknown): item is Block {
    return reflection.isInstance(item, Block);
}

export interface CallExpression extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'CallExpression';
    arguments: Array<Expression>
    callee: Reference<NamedElement>
}

export const CallExpression = 'CallExpression';

export function isCallExpression(item: unknown): item is CallExpression {
    return reflection.isInstance(item, CallExpression);
}

export interface EmptyStatement extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'EmptyStatement';
    empty: boolean
}

export const EmptyStatement = 'EmptyStatement';

export function isEmptyStatement(item: unknown): item is EmptyStatement {
    return reflection.isInstance(item, EmptyStatement);
}

export interface ExportDeclarator extends AstNode {
    readonly $container: ExportSpecifier;
    readonly $type: 'ExportDeclarator';
    alias?: string
    element: Reference<NamedElement>
}

export const ExportDeclarator = 'ExportDeclarator';

export function isExportDeclarator(item: unknown): item is ExportDeclarator {
    return reflection.isInstance(item, ExportDeclarator);
}

export interface ExportSpecifier extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'ExportSpecifier';
    bindings: Array<ExportDeclarator>
    specifier?: string
}

export const ExportSpecifier = 'ExportSpecifier';

export function isExportSpecifier(item: unknown): item is ExportSpecifier {
    return reflection.isInstance(item, ExportSpecifier);
}

export interface FloatLiteral extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'FloatLiteral';
    value: number
}

export const FloatLiteral = 'FloatLiteral';

export function isFloatLiteral(item: unknown): item is FloatLiteral {
    return reflection.isInstance(item, FloatLiteral);
}

export interface GeneratorFunctionDeclaration extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'GeneratorFunctionDeclaration';
    body: Block
    name: string
    parameters: Array<Parameter>
    returnType?: TypeExpression
}

export const GeneratorFunctionDeclaration = 'GeneratorFunctionDeclaration';

export function isGeneratorFunctionDeclaration(item: unknown): item is GeneratorFunctionDeclaration {
    return reflection.isInstance(item, GeneratorFunctionDeclaration);
}

export interface GeneratorFunctionExpression extends AstNode {
    readonly $type: 'GeneratorFunctionExpression';
    body: Block
    name?: string
    parameters: Array<Parameter>
    returnType?: TypeExpression
}

export const GeneratorFunctionExpression = 'GeneratorFunctionExpression';

export function isGeneratorFunctionExpression(item: unknown): item is GeneratorFunctionExpression {
    return reflection.isInstance(item, GeneratorFunctionExpression);
}

export interface GroupLiteral extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'GroupLiteral';
    value: Expression
}

export const GroupLiteral = 'GroupLiteral';

export function isGroupLiteral(item: unknown): item is GroupLiteral {
    return reflection.isInstance(item, GroupLiteral);
}

export interface Identifier extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'Identifier';
    element: Reference<NamedElement>
}

export const Identifier = 'Identifier';

export function isIdentifier(item: unknown): item is Identifier {
    return reflection.isInstance(item, Identifier);
}

export interface ImportDeclaration extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'ImportDeclaration';
    bindings: Array<ImportSpecifier>
    specifier: string
}

export const ImportDeclaration = 'ImportDeclaration';

export function isImportDeclaration(item: unknown): item is ImportDeclaration {
    return reflection.isInstance(item, ImportDeclaration);
}

export interface ImportSpecifier extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'ImportSpecifier';
    alias?: string
    name: string
}

export const ImportSpecifier = 'ImportSpecifier';

export function isImportSpecifier(item: unknown): item is ImportSpecifier {
    return reflection.isInstance(item, ImportSpecifier);
}

export interface IntegerLiteral extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'IntegerLiteral';
    value: number
}

export const IntegerLiteral = 'IntegerLiteral';

export function isIntegerLiteral(item: unknown): item is IntegerLiteral {
    return reflection.isInstance(item, IntegerLiteral);
}

export interface InvalidParenthesis extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'InvalidParenthesis';
    empty: boolean
}

export const InvalidParenthesis = 'InvalidParenthesis';

export function isInvalidParenthesis(item: unknown): item is InvalidParenthesis {
    return reflection.isInstance(item, InvalidParenthesis);
}

export interface OriginalFunctionDeclaration extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'OriginalFunctionDeclaration';
    body: Block
    name: string
    parameters: Array<Parameter>
    returnType?: TypeExpression
}

export const OriginalFunctionDeclaration = 'OriginalFunctionDeclaration';

export function isOriginalFunctionDeclaration(item: unknown): item is OriginalFunctionDeclaration {
    return reflection.isInstance(item, OriginalFunctionDeclaration);
}

export interface OriginalFunctionExpression extends AstNode {
    readonly $type: 'OriginalFunctionExpression';
    body: Block
    name?: string
    parameters: Array<Parameter>
    returnType?: TypeExpression
}

export const OriginalFunctionExpression = 'OriginalFunctionExpression';

export function isOriginalFunctionExpression(item: unknown): item is OriginalFunctionExpression {
    return reflection.isInstance(item, OriginalFunctionExpression);
}

export interface Parameter extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'Parameter';
    name: string
    type?: TypeExpression
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface ReturnStatement extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'ReturnStatement';
    expression: Expression
}

export const ReturnStatement = 'ReturnStatement';

export function isReturnStatement(item: unknown): item is ReturnStatement {
    return reflection.isInstance(item, ReturnStatement);
}

export interface TopLevel extends AstNode {
    readonly $type: 'TopLevel';
    statements: Array<TopLevelStatement>
}

export const TopLevel = 'TopLevel';

export function isTopLevel(item: unknown): item is TopLevel {
    return reflection.isInstance(item, TopLevel);
}

export interface TypeDeclaration extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'TypeDeclaration';
    name: string
    value: TypeExpression
}

export const TypeDeclaration = 'TypeDeclaration';

export function isTypeDeclaration(item: unknown): item is TypeDeclaration {
    return reflection.isInstance(item, TypeDeclaration);
}

export interface TypeExpression extends AstNode {
    readonly $container: ArrowFunctionExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | OriginalFunctionDeclaration | OriginalFunctionExpression | Parameter | TypeDeclaration | VariableDeclaration;
    readonly $type: 'TypeExpression';
    primitive: 'f32' | 'f64' | 'i32' | 'number'
}

export const TypeExpression = 'TypeExpression';

export function isTypeExpression(item: unknown): item is TypeExpression {
    return reflection.isInstance(item, TypeExpression);
}

export interface VariableDeclaration extends AstNode {
    readonly $container: ArrowFunctionExpression | ArrowReturnExpression | BinaryExpression | Block | CallExpression | GeneratorFunctionDeclaration | GeneratorFunctionExpression | GroupLiteral | ImportDeclaration | OriginalFunctionDeclaration | OriginalFunctionExpression | ReturnStatement | TopLevel | VariableDeclaration;
    readonly $type: 'VariableDeclaration';
    name: string
    type?: TypeExpression
    value?: Expression
    variant: 'const' | 'let' | 'var'
}

export const VariableDeclaration = 'VariableDeclaration';

export function isVariableDeclaration(item: unknown): item is VariableDeclaration {
    return reflection.isInstance(item, VariableDeclaration);
}

export interface ByteScriptAstType {
    ArrowFunctionExpression: ArrowFunctionExpression
    ArrowReturnExpression: ArrowReturnExpression
    BinaryExpression: BinaryExpression
    Block: Block
    CallExpression: CallExpression
    EmptyStatement: EmptyStatement
    ExportDeclarator: ExportDeclarator
    ExportSpecifier: ExportSpecifier
    ExportedFunctionDeclaration: ExportedFunctionDeclaration
    ExportedVariableDeclaration: ExportedVariableDeclaration
    Expression: Expression
    FloatLiteral: FloatLiteral
    FunctionDeclaration: FunctionDeclaration
    FunctionExpression: FunctionExpression
    GeneratorFunctionDeclaration: GeneratorFunctionDeclaration
    GeneratorFunctionExpression: GeneratorFunctionExpression
    GroupLiteral: GroupLiteral
    Identifier: Identifier
    ImportDeclaration: ImportDeclaration
    ImportSpecifier: ImportSpecifier
    IntegerLiteral: IntegerLiteral
    InvalidParenthesis: InvalidParenthesis
    NamedElement: NamedElement
    NumberLiteral: NumberLiteral
    OriginalFunctionDeclaration: OriginalFunctionDeclaration
    OriginalFunctionExpression: OriginalFunctionExpression
    Parameter: Parameter
    ReturnStatement: ReturnStatement
    Statement: Statement
    TopLevel: TopLevel
    TopLevelStatement: TopLevelStatement
    TypeDeclaration: TypeDeclaration
    TypeExpression: TypeExpression
    VariableDeclaration: VariableDeclaration
}

export class ByteScriptAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['ArrowFunctionExpression', 'ArrowReturnExpression', 'BinaryExpression', 'Block', 'CallExpression', 'EmptyStatement', 'ExportDeclarator', 'ExportSpecifier', 'ExportedFunctionDeclaration', 'ExportedVariableDeclaration', 'Expression', 'FloatLiteral', 'FunctionDeclaration', 'FunctionExpression', 'GeneratorFunctionDeclaration', 'GeneratorFunctionExpression', 'GroupLiteral', 'Identifier', 'ImportDeclaration', 'ImportSpecifier', 'IntegerLiteral', 'InvalidParenthesis', 'NamedElement', 'NumberLiteral', 'OriginalFunctionDeclaration', 'OriginalFunctionExpression', 'Parameter', 'ReturnStatement', 'Statement', 'TopLevel', 'TopLevelStatement', 'TypeDeclaration', 'TypeExpression', 'VariableDeclaration'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case ArrowFunctionExpression:
            case GeneratorFunctionExpression:
            case OriginalFunctionExpression: {
                return this.isSubtype(FunctionExpression, supertype);
            }
            case BinaryExpression:
            case CallExpression:
            case GroupLiteral:
            case Identifier:
            case InvalidParenthesis:
            case NumberLiteral: {
                return this.isSubtype(Expression, supertype);
            }
            case Block:
            case EmptyStatement:
            case ReturnStatement:
            case Expression: {
                return this.isSubtype(Statement, supertype);
            }
            case ExportSpecifier:
            case ImportDeclaration:
            case TypeDeclaration:
            case ExportedFunctionDeclaration:
            case ExportedVariableDeclaration:
            case Statement: {
                return this.isSubtype(TopLevelStatement, supertype);
            }
            case FloatLiteral:
            case IntegerLiteral: {
                return this.isSubtype(NumberLiteral, supertype);
            }
            case GeneratorFunctionDeclaration:
            case OriginalFunctionDeclaration: {
                return this.isSubtype(FunctionDeclaration, supertype);
            }
            case ImportSpecifier:
            case Parameter: {
                return this.isSubtype(NamedElement, supertype);
            }
            case VariableDeclaration: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(ExportedVariableDeclaration, supertype) || this.isSubtype(NamedElement, supertype);
            }
            case FunctionDeclaration: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(ExportedFunctionDeclaration, supertype) || this.isSubtype(NamedElement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'CallExpression:callee':
            case 'ExportDeclarator:element':
            case 'Identifier:element': {
                return NamedElement;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ArrowFunctionExpression': {
                return {
                    name: 'ArrowFunctionExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'Block': {
                return {
                    name: 'Block',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'CallExpression': {
                return {
                    name: 'CallExpression',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'EmptyStatement': {
                return {
                    name: 'EmptyStatement',
                    mandatory: [
                        { name: 'empty', type: 'boolean' }
                    ]
                };
            }
            case 'ExportSpecifier': {
                return {
                    name: 'ExportSpecifier',
                    mandatory: [
                        { name: 'bindings', type: 'array' }
                    ]
                };
            }
            case 'GeneratorFunctionDeclaration': {
                return {
                    name: 'GeneratorFunctionDeclaration',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'GeneratorFunctionExpression': {
                return {
                    name: 'GeneratorFunctionExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'ImportDeclaration': {
                return {
                    name: 'ImportDeclaration',
                    mandatory: [
                        { name: 'bindings', type: 'array' }
                    ]
                };
            }
            case 'InvalidParenthesis': {
                return {
                    name: 'InvalidParenthesis',
                    mandatory: [
                        { name: 'empty', type: 'boolean' }
                    ]
                };
            }
            case 'OriginalFunctionDeclaration': {
                return {
                    name: 'OriginalFunctionDeclaration',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'OriginalFunctionExpression': {
                return {
                    name: 'OriginalFunctionExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'TopLevel': {
                return {
                    name: 'TopLevel',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ByteScriptAstReflection();
